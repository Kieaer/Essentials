package ksp.command

import arc.util.CommandHandler
import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.javapoet.*
import mindustry.gen.Playerc
import java.io.IOException
import javax.lang.model.element.Modifier

class CommandProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    /**
     * Determines the package name for generated code based on the package of the annotated functions.
     * Extracts the base package from the function's package and appends ".generated" to it.
     * For example, if the function is in "essential.core", the generated package will be "essential.core.generated".
     */
    private fun determinePackageName(functions: List<KSFunctionDeclaration>): String {
        if (functions.isEmpty()) {
            return "essential.core.generated" // Default package if no functions
        }

        // Get the package name from the first function's containing file
        val firstFunction = functions.first()
        val packageName = firstFunction.containingFile?.packageName?.asString() ?: ""

        logger.info("Package name: $packageName")

        // Extract the base package (e.g., essential.core, essential.achievements)
        // The pattern is "essential.X" where X is the module name
        val regex = "essential\\.[a-zA-Z0-9]+"
        val pattern = Regex(regex)
        val matchResult = pattern.find(packageName)

        return if (matchResult != null) {
            "${matchResult.value}.generated"
        } else {
            "essential.core.generated" // Default fallback
        }
    }

    /**
     * Finds the package of the Commands class by looking at the parent class of the annotated functions.
     * If no function is in a class named Commands, falls back to the base package.
     */
    private fun findCommandsPackage(functions: List<KSFunctionDeclaration>): String {
        if (functions.isEmpty()) {
            return "essential.core" // Default package if no functions
        }

        // Check if any function is in a class named Commands
        for (function in functions) {
            val parentDeclaration = function.parentDeclaration
            if (parentDeclaration != null && parentDeclaration.simpleName.asString() == "Commands") {
                // Get the package of the parent class
                val packageName = function.containingFile?.packageName?.asString() ?: ""
                return packageName
            }
        }

        // If no function is in a Commands class, check if any file contains a Commands class
        for (function in functions) {
            val file = function.containingFile ?: continue
            val filePackage = file.packageName.asString()
            val fileDeclarations = file.declarations
            for (declaration in fileDeclarations) {
                if (declaration.simpleName.asString() == "Commands") {
                    return filePackage
                }
            }
        }

        // If no Commands class found, fall back to the base package
        val packageName = determinePackageName(functions)
        return packageName.substringBeforeLast(".generated")
    }

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val serverSymbols = resolver.getSymbolsWithAnnotation(ServerCommand::class.qualifiedName!!)
        val clientSymbols = resolver.getSymbolsWithAnnotation(ClientCommand::class.qualifiedName!!)

        val unprocessedServer = serverSymbols.filter { !it.validate() }.toList()
        val unprocessedClient = clientSymbols.filter { !it.validate() }.toList()

        // Generate server commands
        if (serverSymbols.any()) {
            val serverFunctions = serverSymbols
                .filter { it is KSFunctionDeclaration && it.validate() }
                .map { it as KSFunctionDeclaration }
                .toList()

            if (serverFunctions.isNotEmpty()) {
                generateServerCommandsFile(serverFunctions)
            }
        }

        // Generate client commands
        if (clientSymbols.any()) {
            val clientFunctions = clientSymbols
                .filter { it is KSFunctionDeclaration && it.validate() }
                .map { it as KSFunctionDeclaration }
                .toList()

            if (clientFunctions.isNotEmpty()) {
                generateClientCommandsFile(clientFunctions)
            }
        }

        return unprocessedServer + unprocessedClient
    }

    private fun generateServerCommandsFile(functions: List<KSFunctionDeclaration>) {
        // Determine package name based on the package of the first function
        val packageName = determinePackageName(functions)

        // Find the package of the Commands class by looking at the parent class or file declarations
        val commandsPackage = findCommandsPackage(functions)

        // Get annotation parameter values
        val annotationValues = functions.map { function ->
            val annotation = function.annotations.find { 
                it.shortName.asString() == "ServerCommand" || 
                it.shortName.asString() == "ksp.command.ServerCommand"
            }

            val name = annotation?.arguments?.find { it.name?.asString() == "name" }?.value?.toString() ?: function.simpleName.asString()
            val parameter = annotation?.arguments?.find { it.name?.asString() == "parameter" }?.value?.toString() ?: ""
            val description = annotation?.arguments?.find { it.name?.asString() == "description" }?.value?.toString() ?: "Generated server command"

            Triple(name, parameter, description)
        }

        // Create the registerGeneratedServerCommands method
        val registerMethodBuilder = MethodSpec.methodBuilder("registerGeneratedServerCommands")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(TypeName.VOID)
            .addParameter(ClassName.get("arc.util", "CommandHandler"), "handler")
            .addStatement("$commandsPackage.Commands commands = new $commandsPackage.Commands()")

        // Add command registration for each function
        functions.forEachIndexed { index, function ->
            val (name, parameter, description) = annotationValues[index]

            // Create a unique variable name for the command handler
            val handlerVarName = "handler_${function.simpleName.asString()}"

            // Add code to register the command
            registerMethodBuilder.addCode("\n// Register command: $name\n")
                .addStatement("handler.register($S, $S, $S, args -> {", name, parameter, description)
                .beginControlFlow("if (args.length > 0)")

            if (function.parameters.isEmpty()) {
                registerMethodBuilder.addStatement("commands.${function.simpleName.asString()}()")
            } else {
                registerMethodBuilder.addStatement("commands.${function.simpleName.asString()}(args)")
            }

            registerMethodBuilder.endControlFlow()
                .beginControlFlow("else")
                .beginControlFlow("try")

            if (function.parameters.isEmpty()) {
                registerMethodBuilder.addStatement("commands.${function.simpleName.asString()}()")
            } else {
                registerMethodBuilder.addStatement("commands.${function.simpleName.asString()}(new String[0])")
            }

            registerMethodBuilder.nextControlFlow("catch (Exception e)")
                .addStatement("arc.util.Log.err(\"arg size - 0\")")
                .addStatement("arc.util.Log.err(\"command - \" + $S)", name)
                .endControlFlow()
                .endControlFlow()
                .addStatement("})")
        }

        val registerMethod = registerMethodBuilder.build()

        // Create the ServerCommandsGenerated class
        val typeSpec = TypeSpec.classBuilder("ServerCommandsGenerated")
            .addModifiers(Modifier.PUBLIC)
            .addMethod(registerMethod)
            .build()

        // Create the Java file
        val javaFile = JavaFile.builder(packageName, typeSpec)
            .addStaticImport(ClassName.get("arc.util", "Log"), "info", "err")
            .build()

        try {
            // Write the file
            val dependencies = Dependencies(true, *functions.mapNotNull { it.containingFile }.toTypedArray())
            val outputStream = codeGenerator.createNewFile(
                dependencies,
                packageName,
                "ServerCommandsGenerated",
                "java"
            )
            outputStream.use { javaFile.writeTo(it) }
        } catch (e: IOException) {
            logger.error("Error writing ServerCommandsGenerated.java: ${e.message}")
        }
    }

    private fun generateClientCommandsFile(functions: List<KSFunctionDeclaration>) {
        // Determine package name based on the package of the first function
        val packageName = determinePackageName(functions)

        // Find the package of the Commands class by looking at the parent class or file declarations
        val commandsPackage = findCommandsPackage(functions)

        // Get annotation parameter values
        val annotationValues = functions.map { function ->
            val annotation = function.annotations.find { 
                it.shortName.asString() == "ClientCommand" || 
                it.shortName.asString() == "ksp.command.ClientCommand"
            }

            val name = annotation?.arguments?.find { it.name?.asString() == "name" }?.value?.toString() ?: function.simpleName.asString()
            val parameter = annotation?.arguments?.find { it.name?.asString() == "parameter" }?.value?.toString() ?: ""
            val description = annotation?.arguments?.find { it.name?.asString() == "description" }?.value?.toString() ?: "Generated client command"

            Triple(name, parameter, description)
        }

        // Create the registerGeneratedClientCommands method
        val registerMethodBuilder = MethodSpec.methodBuilder("registerGeneratedClientCommands")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(TypeName.VOID)
            .addParameter(ClassName.get("arc.util", "CommandHandler"), "handler")
            .addStatement("$commandsPackage.Commands commands = new $commandsPackage.Commands()")

        // Add command registration for each function
        functions.forEachIndexed { index, function ->
            val (name, parameter, description) = annotationValues[index]

            // Create a unique variable name for the command handler
            val handlerVarName = "handler_${function.simpleName.asString()}"

            // Add code to register the command
            registerMethodBuilder.addCode("\n// Register command: $name\n")
                .addStatement("handler.register($S, $S, $S, (args, player) -> {", name, parameter, description)
                .addStatement("essential.database.data.PlayerData data = essential.util.UtilsKt.findPlayerData(player.uuid())")
                .beginControlFlow("if (data != null)")
                .beginControlFlow("if (essential.permission.Permission.check(data, $S))", name)

            if (function.parameters.size == 1) {
                registerMethodBuilder.addStatement("commands.${function.simpleName.asString()}(data)")
            } else {
                registerMethodBuilder.addStatement("commands.${function.simpleName.asString()}(data, args)")
            }

            registerMethodBuilder.nextControlFlow("else")
                .beginControlFlow("if ($S.equals($S))", name, "js")
                .addStatement("player.kick(new essential.bundle.Bundle(player.locale()).get(\"command.js.no.permission\"))")
                .nextControlFlow("else")
                .addStatement("data.send(\"command.permission.false\")")
                .endControlFlow()
                .endControlFlow()
                .endControlFlow()
                .addStatement("})")
        }

        val registerMethod = registerMethodBuilder.build()

        // Create the ClientCommandsGenerated class
        val typeSpec = TypeSpec.classBuilder("ClientCommandsGenerated")
            .addModifiers(Modifier.PUBLIC)
            .addMethod(registerMethod)
            .build()

        // Create the Java file
        val javaFile = JavaFile.builder(packageName, typeSpec)
            .addStaticImport(ClassName.get("arc.util", "Log"), "info", "err")
            .addStaticImport(ClassName.get("essential.util", "UtilsKt"), "findPlayerData")
            .addStaticImport(ClassName.get("essential.permission", "Permission"), "check")
            .build()

        try {
            // Write the file
            val dependencies = Dependencies(true, *functions.mapNotNull { it.containingFile }.toTypedArray())
            val outputStream = codeGenerator.createNewFile(
                dependencies,
                packageName,
                "ClientCommandsGenerated",
                "java"
            )
            outputStream.use { javaFile.writeTo(it) }
        } catch (e: IOException) {
            logger.error("Error writing ClientCommandsGenerated.java: ${e.message}")
        }
    }
}

class CommandProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return CommandProcessor(environment.codeGenerator, environment.logger)
    }
}
